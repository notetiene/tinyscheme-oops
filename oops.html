<html>
<head>
<!-- This file has been generated by unroff 1.0, 09/24/96 13:20:49. -->
<!-- Do not edit! -->
<link rev="made" href="mailto:net@informatik.uni-bremen.de">
<title>An `ms' document</title>
</head><body>
<!--  Conditional requests using \n(.U have been added to most macros -->
<!--  for unroff support; the number register .U is non-zero if the file -->
<!--  is processed by unroff, else zero. -->
<!--  A font suitable for Scheme keywords and program examples must be -->
<!--  mounted on font position 5. -->
<!--  For example:  .fp 5 TT  (Typewriter font) -->
<!--           or:  .fp 5 HR  (Helvetica Roman) -->
<!--           or:  .fp 5 C   (Courier) -->
<!--                US paper format. -->
<!--                The subscripts 1 and 2. -->
<!--                The digit 4 as a superscript (used in R^4RS). -->
<!--                Underline page top. -->
<!--                Index entry. -->
<!--                Index entry (definition). -->
<!--                Scheme code start. -->
<!--                Scheme code end. -->
<!--                Scheme keyword in text.  Inline font switches to italics -->
<!--                should be used instead, but at least one document -->
<!--                (oops/oops.ms) still uses this macro. -->
<!--                Chapter with TOC entry. -->
<!--                Called before first in a group of .Pr/.Sy/.Va. -->
<!--                Scheme procedure. -->
<!--                Scheme syntax form. -->
<!--                Scheme variable. -->
<!--                .[[ and .]] enclose a group of .Pr/.Sy/.Va requests. -->
<!--                Output the table of contents. -->
<h1>
The OOPS Package for Elk Scheme
</h1>
<p>
<i>Oliver Laumann
<br>
</i><hr>
<h2>1.&#160;<tt> </tt>Introduction
<a name="toc1">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The OOPS package provides a minimal set of tools that enables
a Scheme programmer to program in an object oriented style.<tt> </tt>
The functionality of OOPS is similar to that of packages like
CLOS and SCOOPS, although the current version does
not support multiple inheritance.<tt> </tt>
The rest of this memo serves as a reference guide to the
OOPS package; the reader is assumed to be familiar with
the terminology of object oriented programming.<tt> </tt>
<br>
<h2>2.&#160;<tt> </tt>Using OOPS
<a name="toc2">&#160;</a>
</h2>
<p>
Programs that make use of the OOPS package should include
the line
<tt></tt><dl><dt><dd>
<pre>
(require 'oops)
</pre>
</dl>
Since this involves autoloading of an object file, it may be desirable
to dump Scheme after the OOPS package has been loaded.<tt> </tt>
<br>
<h2>3.&#160;<tt> </tt>Defining Classes
<a name="toc3">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>New classes are defined by means of the
<tt>define-class
</tt>macro.<tt> </tt>
The syntax of
<tt>define-class
</tt>is
<tt></tt><dl><dt><dd>
<pre>
(define-class <i>class-name</i> . <i>options</i>)
</pre>
</dl>
where <i>class-name</i> is a symbol.<tt> </tt>
<i>options</i> can be of the form
<tt></tt><dl><dt><dd>
<pre>
(super-class <i>class-name</i>)
</pre>
</dl>
where <i>class-name</i> is the name of the super-class (a symbol),
or
<tt></tt><dl><dt><dd>
<pre>
(class-vars . <i>var-specs</i>)
</pre>
</dl>
or
<tt></tt><dl><dt><dd>
<pre>
(instance-vars . <i>var-specs</i>)
</pre>
</dl>
to specify the class variables
and instance variables
of the newly defined class.<tt> </tt>
Each <i>var-spec</i> is either a symbol (the name of the variable)
or of the form
<tt></tt><dl><dt><dd>
<pre>
(<i>symbol</i> <i>initializer</i>).
</pre>
</dl>
Variables for which no initializer has been specified are initialized
to the empty list.<tt> </tt>
The initializers
for class variables are evaluated immediately;
initializers for instance variables are evaluated each time an
instance of the newly defined class is created.<tt> </tt>
Evaluation of initializers is performed in a way that the
initializer of a variable can reference all variables appearing
at the left of the variable being initialized; for instance
<tt></tt><dl><dt><dd>
<pre>
(define-class foo (class-vars (a 10) (b (* a 2))))
</pre>
</dl>
would initialize the class variable
<tt>b
</tt>to 20.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>A class inherits all class variables, instance variables, and
methods of its super-class.<tt> </tt>
When a class and its super-class each have an instance variable
with the same name, the corresponding <i>var-specs</i> must either
both have no initializer or initializers with the same value,
otherwise an ``initializer mismatch'' error is signaled by
<tt>define-class</tt>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Each instance of a class has an instance variable named
<tt>self</tt>.<tt> </tt>
The value of
<tt>self
</tt>is the instance with respect to which
<tt>self
</tt>is evaluated.<tt> </tt>
<tt>self
</tt>can be used by methods as the argument to
<tt>send
</tt>(see below) to invoke another method within the current instance.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><tt>define-class
</tt>does not have a meaningful return value,
instead it has a side-effect on the environment in which it
is invoked.<tt> </tt>
<br>
<h2>4.&#160;<tt> </tt>Creating Instances of a Class
<a name="toc4">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The macro
<tt>make-instance
</tt>is used to create an instance of
a class; it returns the instance as its value.<tt> </tt>
The syntax is
<tt></tt><dl><dt><dd>
<pre>
(make-instance <i>class</i> . <i>args</i>)
</pre>
</dl>
where <i>class</i> is the class of which an instance is to
be created.<tt> </tt>
Each <i>arg</i> of the form
<tt></tt><dl><dt><dd>
<pre>
(<i>symbol</i> <i>initializer</i>)
</pre>
</dl>
where <i>symbol</i> is the name of an instance variable of the class,
is used to initialize the specified instance variable in the
newly created instance.<tt> </tt>
In this case the <i>initializer</i> supersedes any initializer
specified in the call to
<tt>define-class</tt>.<tt> </tt>
Thus it is possible to have instance variables with a <i>default
initializer</i> that can be overridden for individual instances.<tt> </tt>
The initializers are evaluated in the current environment.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><tt>make-instance
</tt>initializes the newly created instance by
invoking the
<tt>initialize-instance
</tt>method for the class
and all super-classes in super-class to sub-class order.<tt> </tt>
That is, the
<tt>initialize-instance
</tt>method of the class specified in the call to
<tt>make-instance
</tt>is called after all other
<tt>initialize-instance
</tt>methods.<tt> </tt>
The arguments passed to the
<tt>initialize-instance
</tt>method of a class are those arguments of the call to
<tt>make-instance
</tt>that do not represent an initialization form for an instance variable.<tt> </tt>
These arguments are evaluated in the current environment.<tt> </tt>
It is not required for a class to have an
<tt>initialize-instance
</tt>method.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Consider the following example:
<tt></tt><dl><dt><dd>
<pre>
(require 'oops)
(define-class c (instance-vars a))
(define-class d (instance-vars (b 10)) (super-class c))
(define-method c (initialize-instance . args)
  (print (cons 'c args)))
(define-method d (initialize-instance . args)
  (print (cons 'd args)))
</pre>
</dl>
In this example evaluation of
<tt></tt><dl><dt><dd>
<pre>
(define x 99)
(define i (make-instance d (a 20) 'foo (b x) x))
</pre>
</dl>
would print
<tt></tt><dl><dt><dd>
<pre>
(c foo 99)
(d foo 99)
</pre>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Note that first the
<tt>initialize-instance
</tt>method of
<tt>c
</tt>is invoked and then that of the class
<tt>d</tt>.<tt> </tt>
The instance variables
<tt>a
</tt>and
<tt>b
</tt>would be initialized to 20 and 99, respectively.<tt> </tt>
<br>
<h2>5.&#160;<tt> </tt>Defining Methods
<a name="toc5">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>A new method can be defined by means of the
<tt>define-method
</tt>macro.<tt> </tt>
The syntax is
<tt></tt><dl><dt><dd>
<pre>
(define-method <i>class</i> <i>lambda-list</i> . <i>body</i>)
</pre>
</dl>
where <i>class</i> is the class to which the method is to be
added, <i>lambda-list</i> is a list specifying the method's
name and formal arguments (having the same syntax as the argument
of
<tt>define</tt>).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><tt>define-method
</tt>simply creates a class-variable with the name
of the method, creates a lambda closure using the <i>lambda-list</i>
and the <i>body</i> forms, and binds the resulting procedure to
the newly-created variable.<tt> </tt>
When a message with the name of the method is sent to an instance
of the class, the method is invoked, and the <i>body</i> is evaluated
in the scope of the instance (so that it can access all instance
and class variables).<tt> </tt>
<br>
<h2>6.&#160;<tt> </tt>Sending Messages
<a name="toc6">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>A message can be sent to an instance by means of the function
<tt>send</tt>.<tt> </tt>
The syntax of
<tt>send
</tt>is
<tt></tt><dl><dt><dd>
<pre>
(send <i>instance</i> <i>message</i> . <i>args</i>)
</pre>
</dl>
where <i>instance</i> is the instance to which the message is
to be sent, <i>message</i> is the name of the method to be
invoked (a symbol), and <i>args</i> are the arguments to be
passed to the method.<tt> </tt>
Example:
<tt></tt><dl><dt><dd>
<pre>
(define-class c (instance-vars a) (class-vars (b 10)))
(define-method c (foo x)
  (cons (set! a x) b))     ; set! returns previous value
(define i (make-instance c (a 99)))

(send i 'foo 1)          returns  (99 . 10)
(send i 'foo 2)          returns  (1 . 10)
</pre>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>When a message is sent to an instance for which no method has
been defined, a ``message not understood'' error is signaled.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The function
<tt>send-if-handles
</tt>is identical to
<tt>send</tt>,
except that it returns a list of one element, the return value
of the method, or
<tt>#f
</tt>when the message is not understood by the instance.<tt> </tt>
<br>
<h2>7.&#160;<tt> </tt>Evaluating Expressions within an Instance
<a name="toc7">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The macro
<tt>with-instance
</tt>can be used to evaluate expressions within the scope of an instance.<tt> </tt>
The syntax is
<tt></tt><dl><dt><dd>
<pre>
(with-instance <i>instance</i> . <i>body</i>).
</pre>
</dl>
The <i>body</i> forms are evaluated in the same environment in
which a method of <i>instance</i> would be evaluated,
i.e. they can access all and class and instance variables
(including
<tt>self</tt>).<tt> </tt>
<tt>with-instance
</tt>returns the value of the last <i>body</i> form.<tt> </tt>
Example:
<tt></tt><dl><dt><dd>
<pre>
(define-class c (class-vars (x 5)) (instance-vars y))
(define i (make-instance c (y 1)))
(define x 10)
(with-instance i (cons x y))          returns  (5 . 1)
</pre>
</dl>
<br>
<h2>8.&#160;<tt> </tt>Setting Instance and Class Variables
<a name="toc8">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Generally class and instance variables are manipulated by methods
or, if applicable, from within a
<tt>with-instance
</tt>form.<tt> </tt>
In addition, values can be assigned to class and instance variables
without involving a message send by means of the
<tt>instance-set!<tt> </tt>
</tt>macro.<tt> </tt>
The syntax of
<tt>instance-set!<tt> </tt>
</tt>is
<tt></tt><dl><dt><dd>
<pre>
(instance-set! <i>instance</i> <i>variable</i> <i>value</i>)
</pre>
</dl>
where <i>variable</i> is a symbol, the name of the class or
instance variable.<tt> </tt>
<tt>instance-set!<tt> </tt>
</tt>returns the previous value of the variable (like
<tt>set!</tt>).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Class variables can be modified without involving an instance
of the class by means of the macro
<tt>class-set!</tt>:
<tt></tt><dl><dt><dd>
<pre>
(class-set! <i>class</i> <i>variable</i> <i>value</i>).
</pre>
</dl>
<i>variable</i> must be the name of a class variable of <i>class</i>.<tt> </tt>
Note that one difference between
<tt></tt><dl><dt><dd>
<pre>
(instance-set! i 'var x)
</pre>
</dl>
and
<tt></tt><dl><dt><dd>
<pre>
(with-instance i (set! var x))
</pre>
</dl>
is that in the former case
<tt>x
</tt>is evaluated in the current environment while in the latter case
<tt>x
</tt>is evaluated within the scope of the instance (here
<tt>x
</tt>might be a class or instance variable).<tt> </tt>
<br>
<h2>9.&#160;<tt> </tt>Obtaining Information about Classes and Instances
<a name="toc9">&#160;</a>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The function
<tt>class-name
</tt>returns the name of a class (a symbol) or, when applied to an instance,
the name of the class of which it is an instance.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The predicate
<tt>method-known?<tt> </tt>
</tt>can be used to check whether a method of a given name is known to a class.<tt> </tt>
The syntax is
<tt></tt><dl><dt><dd>
<pre>
(method-known? <i>method</i> <i>class</i>)
</pre>
</dl>
where <i>method</i> is a symbol.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The type predicates
<tt>class?<tt> </tt>
</tt>and
<tt>instance?<tt> </tt>
</tt>can be used to check whether an object is a class or an instance,
respectively.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The functions
<tt></tt><dl><dt><dd>
<pre>
(check-class <i>symbol</i> <i>object</i>)
</pre>
</dl>
and
<tt></tt><dl><dt><dd>
<pre>
(check-instance <i>symbol</i> <i>object</i>)
</pre>
</dl>
check whether <i>object</i> is a class (i.e. satisfies the predicate
<tt>class?</tt>)
or an instance, respectively, and, if not, signal an error;
in this case <i>symbol</i> is used as the first argument to
<tt>error</tt>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The functions
<tt>describe-class
</tt>and
<tt>describe-instance
</tt>print the components (name, class/instance variables, etc.) of
a class or instance, respectively.<tt> </tt>
The function
<tt>describe
</tt>has been extended in way that when
<tt>(feature? 'oops)
</tt>is true,
<tt>describe-class
</tt>or
<tt>describe-instance
</tt>are called when
<tt>describe
</tt>is applied to an object that satisfies
<tt>class?<tt> </tt>
</tt>or
<tt>instance?</tt>,
respectively.<tt> </tt>
<h2>Table of Contents</h2>
<a href="oops.html#toc1">Introduction
</a>
<br>
<a href="oops.html#toc2">Using OOPS
</a>
<br>
<a href="oops.html#toc3">Defining Classes
</a>
<br>
<a href="oops.html#toc4">Creating Instances of a Class
</a>
<br>
<a href="oops.html#toc5">Defining Methods
</a>
<br>
<a href="oops.html#toc6">Sending Messages
</a>
<br>
<a href="oops.html#toc7">Evaluating Expressions within an Instance
</a>
<br>
<a href="oops.html#toc8">Setting Instance and Class Variables
</a>
<br>
<a href="oops.html#toc9">Obtaining Information about Classes and Instances
</a>
<br>
<p><hr>
Markup created by <em>unroff</em> 1.0,&#160;<tt> </tt>&#160;<tt> </tt>September 24, 1996,&#160;<tt> </tt>&#160;<tt> </tt>net@informatik.uni-bremen.de</body>
</html>
